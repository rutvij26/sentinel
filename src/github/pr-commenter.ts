import { ReviewResult, ReviewComment, TestSuggestion, LintIssue } from '../types';
import { Logger } from '../utils/logger';

export class PRCommenter {
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  async postReviewSummary(
    octokit: any,
    owner: string,
    repo: string,
    prNumber: number,
    review: ReviewResult
  ): Promise<void> {
    try {
      this.logger.info('Posting review summary comment');

      const summaryBody = this.buildSummaryComment(review);

      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: summaryBody,
      });

      this.logger.info('Review summary comment posted successfully');
    } catch (error) {
      this.logger.error(
        `Failed to post review summary: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
      throw error;
    }
  }

  async postFileComments(
    octokit: any,
    owner: string,
    repo: string,
    prNumber: number,
    comments: ReviewComment[]
  ): Promise<void> {
    if (comments.length === 0) {
      this.logger.info('No file comments to post');
      return;
    }

    try {
      this.logger.info(`Posting ${comments.length} file comments`);

      // Group comments by file to create review
      const commentsByFile = this.groupCommentsByFile(comments);

      for (const [filePath, fileComments] of Object.entries(commentsByFile)) {
        await this.postFileReview(octokit, owner, repo, prNumber, filePath, fileComments);
      }

      this.logger.info('All file comments posted successfully');
    } catch (error) {
      this.logger.error(
        `Failed to post file comments: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
      throw error;
    }
  }

  async postTestSuggestions(
    octokit: any,
    owner: string,
    repo: string,
    prNumber: number,
    tests: TestSuggestion[]
  ): Promise<void> {
    if (tests.length === 0) {
      this.logger.info('No test suggestions to post');
      return;
    }

    try {
      this.logger.info('Posting test suggestions comment');

      const testBody = this.buildTestSuggestionsComment(tests);

      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: testBody,
      });

      this.logger.info('Test suggestions comment posted successfully');
    } catch (error) {
      this.logger.error(
        `Failed to post test suggestions: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
      throw error;
    }
  }

  async postLintIssues(
    octokit: any,
    owner: string,
    repo: string,
    prNumber: number,
    issues: LintIssue[]
  ): Promise<void> {
    if (issues.length === 0) {
      this.logger.info('No lint issues to post');
      return;
    }

    try {
      this.logger.info('Posting lint issues comment');

      const lintBody = this.buildLintIssuesComment(issues);

      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: lintBody,
      });

      this.logger.info('Lint issues comment posted successfully');
    } catch (error) {
      this.logger.error(
        `Failed to post lint issues: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
      throw error;
    }
  }

  private buildSummaryComment(review: ReviewResult): string {
    let body = '## ü§ñ Sentinel AI Review Summary\n\n';

    body += `**${review.summary}**\n\n`;

    if (review.suggestions.length > 0) {
      body += '### üí° General Suggestions\n';
      review.suggestions.forEach((suggestion) => {
        body += `- ${suggestion}\n`;
      });
      body += '\n';
    }

    if (review.comments.length > 0) {
      body += `### üìù Code Comments (${review.comments.length})\n`;
      body += 'See inline comments for specific feedback.\n\n';
    }

    body += '---\n';
    body +=
      '*This review was generated by Sentinel AI. Use `/re-review` to regenerate or `/explain <file>` for detailed explanations.*';

    return body;
  }

  private buildTestSuggestionsComment(tests: TestSuggestion[]): string {
    let body = '## üß™ Test Suggestions\n\n';

    tests.forEach((test) => {
      body += `### üìÅ ${test.file}\n`;
      body += `${test.description}\n\n`;

      body += '**Suggested Test Cases:**\n';
      test.testCases.forEach((testCase) => {
        body += `- [ ] ${testCase}\n`;
      });
      body += '\n';
    });

    body += '---\n';
    body +=
      '*Generated by Sentinel AI. Consider implementing these tests to improve code coverage.*';

    return body;
  }

  private buildLintIssuesComment(issues: LintIssue[]): string {
    let body = '## üîç Code Quality Analysis\n\n';

    const issuesBySeverity = {
      error: issues.filter((i) => i.severity === 'error'),
      warning: issues.filter((i) => i.severity === 'warning'),
      info: issues.filter((i) => i.severity === 'info'),
    };

    if (issuesBySeverity.error.length > 0) {
      body += '### ‚ùå Critical Issues\n';
      issuesBySeverity.error.forEach((issue) => {
        body += `- **${issue.file}:${issue.line}** - ${issue.message}`;
        if (issue.rule) body += ` (${issue.rule})`;
        body += '\n';
      });
      body += '\n';
    }

    if (issuesBySeverity.warning.length > 0) {
      body += '### ‚ö†Ô∏è Warnings\n';
      issuesBySeverity.warning.forEach((issue) => {
        body += `- **${issue.file}:${issue.line}** - ${issue.message}`;
        if (issue.rule) body += ` (${issue.rule})`;
        body += '\n';
      });
      body += '\n';
    }

    if (issuesBySeverity.info.length > 0) {
      body += '### ‚ÑπÔ∏è Suggestions\n';
      issuesBySeverity.info.forEach((issue) => {
        body += `- **${issue.file}:${issue.line}** - ${issue.message}`;
        if (issue.rule) body += ` (${issue.rule})`;
        body += '\n';
      });
      body += '\n';
    }

    body += '---\n';
    body += '*Generated by Sentinel AI. Address these issues to improve code quality.*';

    return body;
  }

  private groupCommentsByFile(comments: ReviewComment[]): Record<string, ReviewComment[]> {
    const grouped: Record<string, ReviewComment[]> = {};

    comments.forEach((comment) => {
      if (!grouped[comment.path]) {
        grouped[comment.path] = [];
      }
      grouped[comment.path].push(comment);
    });

    return grouped;
  }

  private async postFileReview(
    octokit: any,
    owner: string,
    repo: string,
    prNumber: number,
    filePath: string,
    comments: ReviewComment[]
  ): Promise<void> {
    try {
      // Create review comments
      const reviewComments = comments.map((comment) => ({
        path: comment.path,
        line: comment.line,
        body: this.formatCommentBody(comment),
      }));

      await octokit.rest.pulls.createReview({
        owner,
        repo,
        pull_number: prNumber,
        body: `Sentinel AI review for ${filePath}`,
        comments: reviewComments,
        event: 'comment', // Don't approve/reject, just comment
      });

      this.logger.info(`Posted ${comments.length} comments for ${filePath}`);
    } catch (error) {
      this.logger.warning(
        `Failed to post review for ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
      // Continue with other files even if one fails
    }
  }

  private formatCommentBody(comment: ReviewComment): string {
    let body = '';

    switch (comment.type) {
      case 'bug':
        body += 'üêõ **Potential Issue:** ';
        break;
      case 'suggestion':
        body += 'üí° **Suggestion:** ';
        break;
      case 'question':
        body += '‚ùì **Question:** ';
        break;
      case 'praise':
        body += 'üëç **Good Practice:** ';
        break;
      default:
        body += 'üìù **Comment:** ';
    }

    body += comment.body;
    body += '\n\n---\n*Generated by Sentinel AI*';

    return body;
  }
}
