"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PRCommenter = void 0;
class PRCommenter {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    async postReviewSummary(octokit, owner, repo, prNumber, review) {
        try {
            this.logger.info('Posting review summary comment');
            const summaryBody = this.buildSummaryComment(review);
            await octokit.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: summaryBody,
            });
            this.logger.info('Review summary comment posted successfully');
        }
        catch (error) {
            this.logger.error(`Failed to post review summary: ${error instanceof Error ? error.message : 'Unknown error'}`);
            throw error;
        }
    }
    async postFileComments(octokit, owner, repo, prNumber, comments) {
        if (comments.length === 0) {
            this.logger.info('No file comments to post');
            return;
        }
        try {
            this.logger.info(`Posting ${comments.length} file comments`);
            // Group comments by file to create review
            const commentsByFile = this.groupCommentsByFile(comments);
            for (const [filePath, fileComments] of Object.entries(commentsByFile)) {
                await this.postFileReview(octokit, owner, repo, prNumber, filePath, fileComments);
            }
            this.logger.info('All file comments posted successfully');
        }
        catch (error) {
            this.logger.error(`Failed to post file comments: ${error instanceof Error ? error.message : 'Unknown error'}`);
            throw error;
        }
    }
    async postTestSuggestions(octokit, owner, repo, prNumber, tests) {
        if (tests.length === 0) {
            this.logger.info('No test suggestions to post');
            return;
        }
        try {
            this.logger.info('Posting test suggestions comment');
            const testBody = this.buildTestSuggestionsComment(tests);
            await octokit.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: testBody,
            });
            this.logger.info('Test suggestions comment posted successfully');
        }
        catch (error) {
            this.logger.error(`Failed to post test suggestions: ${error instanceof Error ? error.message : 'Unknown error'}`);
            throw error;
        }
    }
    async postLintIssues(octokit, owner, repo, prNumber, issues) {
        if (issues.length === 0) {
            this.logger.info('No lint issues to post');
            return;
        }
        try {
            this.logger.info('Posting lint issues comment');
            const lintBody = this.buildLintIssuesComment(issues);
            await octokit.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: lintBody,
            });
            this.logger.info('Lint issues comment posted successfully');
        }
        catch (error) {
            this.logger.error(`Failed to post lint issues: ${error instanceof Error ? error.message : 'Unknown error'}`);
            throw error;
        }
    }
    buildSummaryComment(review) {
        let body = '## 🤖 Sentinel AI Review Summary\n\n';
        body += `**${review.summary}**\n\n`;
        if (review.suggestions.length > 0) {
            body += '### 💡 General Suggestions\n';
            review.suggestions.forEach((suggestion) => {
                body += `- ${suggestion}\n`;
            });
            body += '\n';
        }
        if (review.comments.length > 0) {
            body += `### 📝 Code Comments (${review.comments.length})\n`;
            body += 'See inline comments for specific feedback.\n\n';
        }
        body += '---\n';
        body +=
            '*This review was generated by Sentinel AI. Use `/re-review` to regenerate or `/explain <file>` for detailed explanations.*';
        return body;
    }
    buildTestSuggestionsComment(tests) {
        let body = '## 🧪 Test Suggestions\n\n';
        tests.forEach((test) => {
            body += `### 📁 ${test.file}\n`;
            body += `${test.description}\n\n`;
            body += '**Suggested Test Cases:**\n';
            test.testCases.forEach((testCase) => {
                body += `- [ ] ${testCase}\n`;
            });
            body += '\n';
        });
        body += '---\n';
        body +=
            '*Generated by Sentinel AI. Consider implementing these tests to improve code coverage.*';
        return body;
    }
    buildLintIssuesComment(issues) {
        let body = '## 🔍 Code Quality Analysis\n\n';
        const issuesBySeverity = {
            error: issues.filter((i) => i.severity === 'error'),
            warning: issues.filter((i) => i.severity === 'warning'),
            info: issues.filter((i) => i.severity === 'info'),
        };
        if (issuesBySeverity.error.length > 0) {
            body += '### ❌ Critical Issues\n';
            issuesBySeverity.error.forEach((issue) => {
                body += `- **${issue.file}:${issue.line}** - ${issue.message}`;
                if (issue.rule)
                    body += ` (${issue.rule})`;
                body += '\n';
            });
            body += '\n';
        }
        if (issuesBySeverity.warning.length > 0) {
            body += '### ⚠️ Warnings\n';
            issuesBySeverity.warning.forEach((issue) => {
                body += `- **${issue.file}:${issue.line}** - ${issue.message}`;
                if (issue.rule)
                    body += ` (${issue.rule})`;
                body += '\n';
            });
            body += '\n';
        }
        if (issuesBySeverity.info.length > 0) {
            body += '### ℹ️ Suggestions\n';
            issuesBySeverity.info.forEach((issue) => {
                body += `- **${issue.file}:${issue.line}** - ${issue.message}`;
                if (issue.rule)
                    body += ` (${issue.rule})`;
                body += '\n';
            });
            body += '\n';
        }
        body += '---\n';
        body += '*Generated by Sentinel AI. Address these issues to improve code quality.*';
        return body;
    }
    groupCommentsByFile(comments) {
        const grouped = {};
        comments.forEach((comment) => {
            if (!grouped[comment.path]) {
                grouped[comment.path] = [];
            }
            grouped[comment.path].push(comment);
        });
        return grouped;
    }
    async postFileReview(octokit, owner, repo, prNumber, filePath, comments) {
        try {
            // Create review comments
            const reviewComments = comments.map((comment) => ({
                path: comment.path,
                line: comment.line,
                body: this.formatCommentBody(comment),
            }));
            await octokit.rest.pulls.createReview({
                owner,
                repo,
                pull_number: prNumber,
                body: `Sentinel AI review for ${filePath}`,
                comments: reviewComments,
                event: 'comment', // Don't approve/reject, just comment
            });
            this.logger.info(`Posted ${comments.length} comments for ${filePath}`);
        }
        catch (error) {
            this.logger.warning(`Failed to post review for ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            // Continue with other files even if one fails
        }
    }
    formatCommentBody(comment) {
        let body = '';
        switch (comment.type) {
            case 'bug':
                body += '🐛 **Potential Issue:** ';
                break;
            case 'suggestion':
                body += '💡 **Suggestion:** ';
                break;
            case 'question':
                body += '❓ **Question:** ';
                break;
            case 'praise':
                body += '👍 **Good Practice:** ';
                break;
            default:
                body += '📝 **Comment:** ';
        }
        body += comment.body;
        body += '\n\n---\n*Generated by Sentinel AI*';
        return body;
    }
}
exports.PRCommenter = PRCommenter;
//# sourceMappingURL=pr-commenter.js.map